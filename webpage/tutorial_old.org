#+TITLE: Illinois-SL Tutorial
#+STARTUP: customtime
#+OPTIONS: tags:nil num:nil
#+INCLUDE: "~/Dropbox/Private/org/revision/my_latex_preamble.org"

* Installation
You can download the Illinois-SL package from [[http://cogcomp.cs.illinois.edu/][here]].
* Getting Started
This is a tutorial for the Illinois-SL package. We will walk you through installation, some simple examples and other relevant details.

In case of problems, you can contact the author at [[mailto:kchang10@illinois.edu][kchang10@illinois.edu]] or [[mailto:upadhya3@illinois.edu][upadhya3@illinois.edu]].
* Basics
We need to implement the following classes and methods,

1) The input structure, $\x$
2) The output structure, $\y$
3) A procedure =InferenceSolver= to perform the loss-augmented inference.

\begin{align*}
  \argmax_{\y'} \w^T \Phi(\x,\y') + \Delta(\y,\y')
\end{align*}

At test time, we need to solve 
\begin{align*}
  \argmax_{\y'} \w^T \Phi(\x,\y')
\end{align*}

For this we can just set $\Delta(\y,\y')$ to zero in the InfSolver method.

* Example - POS Tagging
  We will start with a very simple example - part-of-speech tagging. 
  To implement a structured learning algorithm, we need to 
* Sentence
For POS Tagging , sentence represents the input structure. Each token in the sentence will be part of the structure. 
#+BEGIN_SRC
public class Sentence implements IInstance {
    public final int[] tokens;
}
#+END_SRC
For each token in the sentence, we just store the id of the token maintained in the lexicon.
Note that all input structures should implement the =IInstance= interface.

* POS Tag
The POS tag sequence represents the output structure. 
#+BEGIN_SRC
public class POSTag implements IStructure {
    public final int[] tags;
    public POSTag(int[] tags){
        this.tags = tags;
    }
}
#+END_SRC
Again, we just store the ids, as maintained by the lexicon. Note that all output structures should implement =IStructure= interface.
* Reading the Training Data
We will assume the training data is in the following format,
#+BEGIN_SRC
I ate an apple .
PRP VBD DT NN .
The quick brown fox jumped over the lazy dog .
DT JJ JJ NN VBD IN DT JJ NN .
#+END_SRC
First the tokens of the sentence are listed, followed by the POS tags for each token.

As we read the data, we will put the words into the lexicon. 
#+BEGIN_SRC
for (int j = 0; j < words.length; j++) {
    // this will be off at test time, so new words wont be added to the lexicon
    if (lm.isAllowNewFeatures()) {
    lm.addFeature("w:" + words[j]);
}
if (lm.containFeature("w:" + words[j]))
    wordIds[j] = lm.getFeatureId("w:" + words[j]);
else
    wordIds[j] = lm.getFeatureId("W:unknownword"); 
    // new word seen at test time, so we map it to unknown.
    // Note that else condition will only occur at test time.
}
Sentence x = new Sentence(wordIds);
#+END_SRC

Similarly, we read the POS tag sequence, adding the labels to the lexicon,
#+BEGIN_SRC
for (int j = 0; j < tags.length; j++) {
    lm.addLabel("tag:" + tags[j]);
    tagIds[j] = lm.getLabelId("tag:" + tags[j]);
}
POSTag y = new POSTag(tagIds);
#+END_SRC
For ease of access, we put both the sentence token ids and the tags ids in the =SLProblem= object. The =SLProblem= class is a wrapper around a list of IInstance and the correponding gold IStructure objects. We add the sentence and POSTag to the =SLProblem= object,
#+BEGIN_SRC
sp.addExample(x, y);
#+END_SRC

Here is the entire code for reading the data,
#+BEGIN_SRC
public static SLProblem readStructuredData(String fname, Lexiconer lm)
throws IOException, DataFormatException {
    List<String> lines = LineIO.read(fname);
    SLProblem sp = new SLProblem();

    assert lines.size() % 2 == 0; // must be even; contains labels

    if (lm.isAllowNewFeatures())
        lm.addFeature("W:unknownword"); 
        // pre-add the unknown word to the vocab

    for (int i = 0; i < lines.size() / 2; i++) {
        String[] words = lines.get(i * 2).split("\\s+");
        int[] wordIds = new int[words.length];

        for (int j = 0; j < words.length; j++) {
        // this will be off at test time, so new words wont be added to the lexicon
            if (lm.isAllowNewFeatures()) {
                lm.addFeature("w:" + words[j]);
            }
            if (lm.containFeature("w:" + words[j]))
                wordIds[j] = lm.getFeatureId("w:" + words[j]);
            else
                wordIds[j] = lm.getFeatureId("W:unknownword");
                // new word seen at test time, so we map it to unknown
        }
        Sentence x = new Sentence(wordIds);
        String[] tags = lines.get(i * 2 + 1).split("\\s+");
        int[] tagIds = new int[words.length];

        if (words.length != tags.length) {
            throw new DataFormatException(
            "The number of tokens and number tags in " + i
            + "-th sample does not match");
        }
        for (int j = 0; j < tags.length; j++) {
            lm.addLabel("tag:" + tags[j]);
            tagIds[j] = lm.getLabelId("tag:" + tags[j]);
        }
        sp.addExample(x, new POSTag(tagIds));
    }
    return sp;
}
#+END_SRC
* Training
First, we create a new =SLModel= object that will contain all the information relevant to our model.
In particular, it contains,
1. The Lexicon - the lexicon manages the mapping from your features to ids and labels to ids. The lexicon is implemented in the class =Lexiconer=.
2. The weight vector for your model.  
3. Inference Solver - the method that you use to solve 

#+BEGIN_SRC

SLModel model = new SLModel();
model.lm = new Lexiconer();

SLProblem sp = readStructuredData(trainingDataPath, model.lm);

#+END_SRC

Now lets read the training data for POS tagging.
We are going to populate the lexicon as we read the data. 
Once you have read all the data, make sure to switch off the addition of new features by calling,
#+BEGIN_SRC
// Disallow the creation of new features
model.lm.setAllowNewFeatures(false);
#+END_SRC
*This is important*. If you forget to do this, the lexicon will keep on adding new words to the vocabulary during test time!


When you are done training, you can save your model by calling the =saveModel= method in the =SLModel= class.

* Testing
